"""
Vulnerability Scanner Module - Automated vulnerability detection
"""

import subprocess
import json
import logging
import re
import requests
import time
from typing import Dict, List, Any, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urljoin, urlparse
import xml.etree.ElementTree as ET

class VulnScanModule:
    """Vulnerability scanning module for automated security testing"""
    
    def __init__(self, config):
        """Initialize vulnerability scanner"""
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.timeout = config.get('general', 'timeout', 30)
        self.max_threads = config.get('general', 'max_threads', 10)
        
    def scan(self, target: str, recon_data: Dict[str, Any]) -> Dict[str, Any]:
        """Perform comprehensive vulnerability scanning"""
        self.logger.info(f"Starting vulnerability scan for {target}")
        
        results = {
            'target': target,
            'vulnerabilities': [],
            'scan_summary': {
                'total_vulnerabilities': 0,
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'info': 0
            },
            'tools_used': [],
            'scan_time': time.time()
        }
        
        try:
            # Web application vulnerabilities
            if self._has_web_services(recon_data):
                self.logger.info("Scanning for web vulnerabilities...")
                web_vulns = self._scan_web_vulnerabilities(target, recon_data)
                results['vulnerabilities'].extend(web_vulns)
                
            # Network vulnerabilities
            self.logger.info("Scanning for network vulnerabilities...")
            network_vulns = self._scan_network_vulnerabilities(target, recon_data)
            results['vulnerabilities'].extend(network_vulns)
            
            # Nuclei template scanning
            self.logger.info("Running Nuclei template scans...")
            nuclei_vulns = self._run_nuclei_scan(target)
            results['vulnerabilities'].extend(nuclei_vulns)
            results['tools_used'].append('nuclei')
            
            # SSL/TLS vulnerabilities
            self.logger.info("Checking SSL/TLS vulnerabilities...")
            ssl_vulns = self._scan_ssl_vulnerabilities(target)
            results['vulnerabilities'].extend(ssl_vulns)
            
            # CMS-specific vulnerabilities
            cms = recon_data.get('technologies', {}).get('cms')
            if cms:
                self.logger.info(f"Scanning for {cms} vulnerabilities...")
                cms_vulns = self._scan_cms_vulnerabilities(target, cms)
                results['vulnerabilities'].extend(cms_vulns)
            
            # SQL injection testing
            self.logger.info("Testing for SQL injection...")
            sqli_vulns = self._test_sql_injection(target, recon_data)
            results['vulnerabilities'].extend(sqli_vulns)
            results['tools_used'].append('sqlmap')
            
            # XSS testing
            self.logger.info("Testing for XSS vulnerabilities...")
            xss_vulns = self._test_xss_vulnerabilities(target, recon_data)
            results['vulnerabilities'].extend(xss_vulns)
            
            # Directory traversal testing
            self.logger.info("Testing for directory traversal...")
            traversal_vulns = self._test_directory_traversal(target, recon_data)
            results['vulnerabilities'].extend(traversal_vulns)
            
            # Update summary
            self._update_scan_summary(results)
            
            self.logger.info(f"Vulnerability scan completed. Found {len(results['vulnerabilities'])} potential issues")
            
        except Exception as e:
            self.logger.error(f"Error during vulnerability scan: {str(e)}")
            raise
        
        return results
    
    def _has_web_services(self, recon_data: Dict[str, Any]) -> bool:
        """Check if target has web services"""
        open_ports = recon_data.get('open_ports', [])
        web_ports = [80, 443, 8080, 8443, 3000, 5000, 8000, 9000]
        
        return any(port['port'] in web_ports for port in open_ports)
    
    def _scan_web_vulnerabilities(self, target: str, recon_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan for web application vulnerabilities"""
        vulnerabilities = []
        
        # Get web services from recon data
        services = recon_data.get('services', {})
        
        for service_key, service_info in services.items():
            if 'http' in service_key:
                url = service_info.get('url')
                if url:
                    # Test common web vulnerabilities
                    vulnerabilities.extend(self._test_common_web_vulns(url))
        
        return vulnerabilities
    
    def _test_common_web_vulns(self, url: str) -> List[Dict[str, Any]]:
        """Test for common web vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Test for information disclosure
            info_vulns = self._test_information_disclosure(url)
            vulnerabilities.extend(info_vulns)
            
            # Test for security headers
            header_vulns = self._test_security_headers(url)
            vulnerabilities.extend(header_vulns)
            
            # Test for default credentials
            default_cred_vulns = self._test_default_credentials(url)
            vulnerabilities.extend(default_cred_vulns)
            
            # Test for backup files
            backup_vulns = self._test_backup_files(url)
            vulnerabilities.extend(backup_vulns)
            
        except Exception as e:
            self.logger.error(f"Error testing web vulnerabilities for {url}: {str(e)}")
        
        return vulnerabilities
    
    def _test_information_disclosure(self, url: str) -> List[Dict[str, Any]]:
        """Test for information disclosure vulnerabilities"""
        vulnerabilities = []
        
        # Common paths that might expose sensitive information
        test_paths = [
            '/.env',
            '/.git/config',
            '/config.php',
            '/phpinfo.php',
            '/server-status',
            '/server-info',
            '/admin',
            '/backup',
            '/test',
            '/debug',
            '/robots.txt',
            '/sitemap.xml'
        ]
        
        for path in test_paths:
            try:
                test_url = urljoin(url, path)
                response = requests.get(test_url, timeout=10, verify=False)
                
                if response.status_code == 200:
                    # Check for sensitive content
                    content = response.text.lower()
                    
                    if path == '/.env' and ('password' in content or 'secret' in content):
                        vulnerabilities.append({
                            'type': 'Information Disclosure',
                            'severity': 'High',
                            'title': 'Environment File Exposed',
                            'description': f'Environment configuration file exposed at {test_url}',
                            'url': test_url,
                            'evidence': response.text[:500]
                        })
                    
                    elif path == '/.git/config':
                        vulnerabilities.append({
                            'type': 'Information Disclosure',
                            'severity': 'Medium',
                            'title': 'Git Configuration Exposed',
                            'description': f'Git configuration file exposed at {test_url}',
                            'url': test_url,
                            'evidence': response.text[:500]
                        })
                    
                    elif path == '/phpinfo.php' and 'php version' in content:
                        vulnerabilities.append({
                            'type': 'Information Disclosure',
                            'severity': 'Medium',
                            'title': 'PHP Info Page Exposed',
                            'description': f'PHP information page exposed at {test_url}',
                            'url': test_url,
                            'evidence': 'PHP configuration details exposed'
                        })
                
            except requests.RequestException:
                continue
        
        return vulnerabilities
    
    def _test_security_headers(self, url: str) -> List[Dict[str, Any]]:
        """Test for missing security headers"""
        vulnerabilities = []
        
        try:
            response = requests.get(url, timeout=10, verify=False)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection missing',
                'X-Content-Type-Options': 'MIME type sniffing protection missing',
                'X-XSS-Protection': 'XSS protection header missing',
                'Strict-Transport-Security': 'HSTS header missing',
                'Content-Security-Policy': 'CSP header missing'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vulnerabilities.append({
                        'type': 'Security Misconfiguration',
                        'severity': 'Low',
                        'title': f'Missing {header} Header',
                        'description': description,
                        'url': url,
                        'evidence': f'Response headers: {dict(headers)}'
                    })
            
        except requests.RequestException as e:
            self.logger.error(f"Error testing security headers: {str(e)}")
        
        return vulnerabilities
    
    def _test_default_credentials(self, url: str) -> List[Dict[str, Any]]:
        """Test for default credentials"""
        vulnerabilities = []
        
        # Common admin paths
        admin_paths = ['/admin', '/administrator', '/wp-admin', '/login']
        
        # Common default credentials
        default_creds = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('admin', '123456'),
            ('root', 'root'),
            ('test', 'test')
        ]
        
        for path in admin_paths:
            try:
                login_url = urljoin(url, path)
                response = requests.get(login_url, timeout=10, verify=False)
                
                if response.status_code == 200 and 'login' in response.text.lower():
                    # Found a login page, test default credentials
                    for username, password in default_creds:
                        if self._test_login(login_url, username, password):
                            vulnerabilities.append({
                                'type': 'Authentication Bypass',
                                'severity': 'Critical',
                                'title': 'Default Credentials',
                                'description': f'Default credentials {username}:{password} work on {login_url}',
                                'url': login_url,
                                'evidence': f'Successfully logged in with {username}:{password}'
                            })
                            break
                
            except requests.RequestException:
                continue
        
        return vulnerabilities
    
    def _test_login(self, login_url: str, username: str, password: str) -> bool:
        """Test login with given credentials"""
        try:
            # Simple POST request test (this is basic and might need improvement)
            data = {
                'username': username,
                'password': password,
                'user': username,
                'pass': password,
                'login': 'Login'
            }
            
            response = requests.post(login_url, data=data, timeout=10, verify=False, allow_redirects=False)
            
            # Check for successful login indicators
            if (response.status_code in [302, 301] or 
                'dashboard' in response.text.lower() or
                'welcome' in response.text.lower()):
                return True
                
        except requests.RequestException:
            pass
        
        return False
    
    def _test_backup_files(self, url: str) -> List[Dict[str, Any]]:
        """Test for backup files"""
        vulnerabilities = []
        
        parsed_url = urlparse(url)
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
        
        # Common backup file patterns
        backup_patterns = [
            'backup.zip',
            'backup.tar.gz',
            'backup.sql',
            'database.sql',
            'dump.sql',
            'site.zip',
            'www.zip',
            'backup.tar'
        ]
        
        for pattern in backup_patterns:
            try:
                backup_url = urljoin(base_url, pattern)
                response = requests.head(backup_url, timeout=10, verify=False)
                
                if response.status_code == 200:
                    vulnerabilities.append({
                        'type': 'Information Disclosure',
                        'severity': 'High',
                        'title': 'Backup File Exposed',
                        'description': f'Backup file accessible at {backup_url}',
                        'url': backup_url,
                        'evidence': f'File size: {response.headers.get("Content-Length", "Unknown")}'
                    })
                
            except requests.RequestException:
                continue
        
        return vulnerabilities
    
    def _scan_network_vulnerabilities(self, target: str, recon_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan for network-level vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Run Nmap vulnerability scripts
            nmap_vulns = self._run_nmap_vuln_scan(target)
            vulnerabilities.extend(nmap_vulns)
            
        except Exception as e:
            self.logger.error(f"Error scanning network vulnerabilities: {str(e)}")
        
        return vulnerabilities
    
    def _run_nmap_vuln_scan(self, target: str) -> List[Dict[str, Any]]:
        """Run Nmap vulnerability scanning scripts"""
        vulnerabilities = []
        
        try:
            cmd = [
                'nmap',
                '--script', 'vuln',
                '-sV',
                '-T4',
                '-oX', f'/tmp/nmap_vuln_{target}.xml',
                target
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            
            if result.returncode == 0:
                # Parse XML output for vulnerabilities
                vulnerabilities = self._parse_nmap_vuln_xml(f'/tmp/nmap_vuln_{target}.xml')
            
        except subprocess.TimeoutExpired:
            self.logger.warning("Nmap vulnerability scan timed out")
        except Exception as e:
            self.logger.error(f"Error running Nmap vulnerability scan: {str(e)}")
        
        return vulnerabilities
    
    def _parse_nmap_vuln_xml(self, xml_file: str) -> List[Dict[str, Any]]:
        """Parse Nmap XML output for vulnerabilities"""
        vulnerabilities = []
        
        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()
            
            for host in root.findall('host'):
                for port in host.findall('.//port'):
                    for script in port.findall('.//script'):
                        script_id = script.get('id', '')
                        script_output = script.get('output', '')
                        
                        if 'vuln' in script_id.lower() and script_output:
                            # Extract vulnerability information
                            severity = self._extract_severity_from_nmap(script_output)
                            
                            vulnerabilities.append({
                                'type': 'Network Vulnerability',
                                'severity': severity,
                                'title': script_id.replace('-', ' ').title(),
                                'description': script_output[:200] + '...' if len(script_output) > 200 else script_output,
                                'port': port.get('portid'),
                                'evidence': script_output
                            })
            
        except Exception as e:
            self.logger.error(f"Error parsing Nmap XML: {str(e)}")
        
        return vulnerabilities
    
    def _extract_severity_from_nmap(self, output: str) -> str:
        """Extract severity from Nmap script output"""
        output_lower = output.lower()
        
        if any(word in output_lower for word in ['critical', 'exploit']):
            return 'Critical'
        elif any(word in output_lower for word in ['high', 'dangerous']):
            return 'High'
        elif any(word in output_lower for word in ['medium', 'moderate']):
            return 'Medium'
        else:
            return 'Low'
    
    def _run_nuclei_scan(self, target: str) -> List[Dict[str, Any]]:
        """Run Nuclei template-based vulnerability scan"""
        vulnerabilities = []
        
        try:
            cmd = [
                'nuclei',
                '-target', target,
                '-silent',
                '-json',
                '-o', f'/tmp/nuclei_{target}.json'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            
            if result.returncode == 0:
                # Parse JSON output
                try:
                    with open(f'/tmp/nuclei_{target}.json', 'r') as f:
                        for line in f:
                            if line.strip():
                                vuln_data = json.loads(line)
                                vulnerabilities.append(self._parse_nuclei_result(vuln_data))
                except FileNotFoundError:
                    pass
            
        except subprocess.TimeoutExpired:
            self.logger.warning("Nuclei scan timed out")
        except Exception as e:
            self.logger.error(f"Error running Nuclei scan: {str(e)}")
        
        return vulnerabilities
    
    def _parse_nuclei_result(self, nuclei_data: Dict[str, Any]) -> Dict[str, Any]:
        """Parse Nuclei scan result"""
        info = nuclei_data.get('info', {})
        
        return {
            'type': 'Template-based Vulnerability',
            'severity': info.get('severity', 'Low').title(),
            'title': info.get('name', 'Unknown Vulnerability'),
            'description': info.get('description', 'No description available'),
            'url': nuclei_data.get('matched-at', ''),
            'template_id': nuclei_data.get('template-id', ''),
            'evidence': nuclei_data.get('extracted-results', [])
        }
    
    def _scan_ssl_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Scan for SSL/TLS vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Test for common SSL/TLS issues
            ssl_vulns = self._test_ssl_issues(target)
            vulnerabilities.extend(ssl_vulns)
            
        except Exception as e:
            self.logger.error(f"Error scanning SSL vulnerabilities: {str(e)}")
        
        return vulnerabilities
    
    def _test_ssl_issues(self, target: str) -> List[Dict[str, Any]]:
        """Test for SSL/TLS configuration issues"""
        vulnerabilities = []
        
        try:
            import ssl
            import socket
            
            # Test SSL connection
            context = ssl.create_default_context()
            
            with socket.create_connection((target, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=target) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check for weak ciphers
                    if cipher and len(cipher) > 1:
                        cipher_name = cipher[0]
                        if any(weak in cipher_name.lower() for weak in ['rc4', 'des', 'md5']):
                            vulnerabilities.append({
                                'type': 'SSL/TLS Vulnerability',
                                'severity': 'Medium',
                                'title': 'Weak SSL Cipher',
                                'description': f'Weak cipher suite in use: {cipher_name}',
                                'evidence': f'Cipher: {cipher}'
                            })
                    
                    # Check certificate validity
                    from datetime import datetime
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    
                    if not_after < datetime.now():
                        vulnerabilities.append({
                            'type': 'SSL/TLS Vulnerability',
                            'severity': 'High',
                            'title': 'Expired SSL Certificate',
                            'description': f'SSL certificate expired on {cert["notAfter"]}',
                            'evidence': f'Certificate expiry: {cert["notAfter"]}'
                        })
            
        except Exception as e:
            # SSL not available or other error
            pass
        
        return vulnerabilities
    
    def _scan_cms_vulnerabilities(self, target: str, cms: str) -> List[Dict[str, Any]]:
        """Scan for CMS-specific vulnerabilities"""
        vulnerabilities = []
        
        if cms.lower() == 'wordpress':
            vulnerabilities.extend(self._scan_wordpress_vulns(target))
        elif cms.lower() == 'drupal':
            vulnerabilities.extend(self._scan_drupal_vulns(target))
        elif cms.lower() == 'joomla':
            vulnerabilities.extend(self._scan_joomla_vulns(target))
        
        return vulnerabilities
    
    def _scan_wordpress_vulns(self, target: str) -> List[Dict[str, Any]]:
        """Scan for WordPress-specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for common WordPress vulnerabilities
            wp_paths = [
                '/wp-admin/',
                '/wp-content/uploads/',
                '/wp-config.php',
                '/wp-content/debug.log'
            ]
            
            for path in wp_paths:
                url = f"http://{target}{path}"
                try:
                    response = requests.get(url, timeout=10, verify=False)
                    
                    if path == '/wp-config.php' and response.status_code == 200:
                        vulnerabilities.append({
                            'type': 'CMS Vulnerability',
                            'severity': 'Critical',
                            'title': 'WordPress Configuration File Exposed',
                            'description': 'wp-config.php file is accessible',
                            'url': url,
                            'evidence': 'Configuration file contains database credentials'
                        })
                    
                    elif path == '/wp-content/debug.log' and response.status_code == 200:
                        vulnerabilities.append({
                            'type': 'Information Disclosure',
                            'severity': 'Medium',
                            'title': 'WordPress Debug Log Exposed',
                            'description': 'Debug log file is accessible',
                            'url': url,
                            'evidence': response.text[:200]
                        })
                
                except requests.RequestException:
                    continue
            
        except Exception as e:
            self.logger.error(f"Error scanning WordPress vulnerabilities: {str(e)}")
        
        return vulnerabilities
    
    def _scan_drupal_vulns(self, target: str) -> List[Dict[str, Any]]:
        """Scan for Drupal-specific vulnerabilities"""
        # Placeholder for Drupal-specific scans
        return []
    
    def _scan_joomla_vulns(self, target: str) -> List[Dict[str, Any]]:
        """Scan for Joomla-specific vulnerabilities"""
        # Placeholder for Joomla-specific scans
        return []
    
    def _test_sql_injection(self, target: str, recon_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for SQL injection vulnerabilities using SQLMap"""
        vulnerabilities = []
        
        try:
            # Get URLs from directory enumeration
            directories = recon_data.get('directories', [])
            test_urls = []
            
            # Add common vulnerable endpoints
            common_endpoints = [
                '/search.php?q=test',
                '/login.php?id=1',
                '/product.php?id=1',
                '/user.php?id=1',
                '/page.php?id=1'
            ]
            
            for endpoint in common_endpoints:
                test_urls.append(f"http://{target}{endpoint}")
            
            # Test a few URLs with SQLMap
            for url in test_urls[:3]:  # Limit to avoid long scan times
                sqli_result = self._run_sqlmap(url)
                if sqli_result:
                    vulnerabilities.append(sqli_result)
            
        except Exception as e:
            self.logger.error(f"Error testing SQL injection: {str(e)}")
        
        return vulnerabilities
    
    def _run_sqlmap(self, url: str) -> Optional[Dict[str, Any]]:
        """Run SQLMap on a specific URL"""
        try:
            cmd = [
                'sqlmap',
                '-u', url,
                '--batch',
                '--random-agent',
                '--level', '1',
                '--risk', '1',
                '--timeout', '10',
                '--retries', '1'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if 'vulnerable' in result.stdout.lower():
                return {
                    'type': 'SQL Injection',
                    'severity': 'High',
                    'title': 'SQL Injection Vulnerability',
                    'description': f'SQL injection found in {url}',
                    'url': url,
                    'evidence': result.stdout[:500]
                }
            
        except subprocess.TimeoutExpired:
            self.logger.warning(f"SQLMap timed out for {url}")
        except Exception as e:
            self.logger.error(f"Error running SQLMap: {str(e)}")
        
        return None
    
    def _test_xss_vulnerabilities(self, target: str, recon_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for XSS vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Simple XSS payload
            xss_payload = "<script>alert('XSS')</script>"
            
            # Test common XSS vectors
            test_params = ['q', 'search', 'query', 'name', 'comment', 'message']
            
            for param in test_params:
                test_url = f"http://{target}/search.php?{param}={xss_payload}"
                
                try:
                    response = requests.get(test_url, timeout=10, verify=False)
                    
                    if xss_payload in response.text:
                        vulnerabilities.append({
                            'type': 'Cross-Site Scripting (XSS)',
                            'severity': 'Medium',
                            'title': 'Reflected XSS Vulnerability',
                            'description': f'XSS vulnerability found in parameter {param}',
                            'url': test_url,
                            'evidence': f'Payload reflected: {xss_payload}'
                        })
                
                except requests.RequestException:
                    continue
            
        except Exception as e:
            self.logger.error(f"Error testing XSS vulnerabilities: {str(e)}")
        
        return vulnerabilities
    
    def _test_directory_traversal(self, target: str, recon_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for directory traversal vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Directory traversal payloads
            traversal_payloads = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '....//....//....//etc/passwd'
            ]
            
            # Test common parameters
            test_params = ['file', 'page', 'include', 'path', 'doc']
            
            for param in test_params:
                for payload in traversal_payloads:
                    test_url = f"http://{target}/index.php?{param}={payload}"
                    
                    try:
                        response = requests.get(test_url, timeout=10, verify=False)
                        
                        # Check for signs of successful traversal
                        if ('root:' in response.text or 
                            'localhost' in response.text or
                            'bin/bash' in response.text):
                            
                            vulnerabilities.append({
                                'type': 'Directory Traversal',
                                'severity': 'High',
                                'title': 'Directory Traversal Vulnerability',
                                'description': f'Directory traversal found in parameter {param}',
                                'url': test_url,
                                'evidence': response.text[:200]
                            })
                            break
                    
                    except requests.RequestException:
                        continue
            
        except Exception as e:
            self.logger.error(f"Error testing directory traversal: {str(e)}")
        
        return vulnerabilities
    
    def _update_scan_summary(self, results: Dict[str, Any]):
        """Update scan summary with vulnerability counts"""
        summary = results['scan_summary']
        
        for vuln in results['vulnerabilities']:
            severity = vuln.get('severity', 'Low').lower()
            summary['total_vulnerabilities'] += 1
            
            if severity == 'critical':
                summary['critical'] += 1
            elif severity == 'high':
                summary['high'] += 1
            elif severity == 'medium':
                summary['medium'] += 1
            elif severity == 'low':
                summary['low'] += 1
            else:
                summary['info'] += 1

